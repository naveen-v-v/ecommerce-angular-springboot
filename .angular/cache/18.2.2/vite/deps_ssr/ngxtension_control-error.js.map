{
  "version": 3,
  "sources": ["../../../../../node_modules/ngxtension/fesm2022/ngxtension-filter-nil.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-control-error.mjs"],
  "sourcesContent": ["import { filter } from 'rxjs';\nconst filterNil = () => filter(value => value !== undefined && value !== null);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { filterNil };\n", "import * as i0 from '@angular/core';\nimport { InjectionToken, inject, TemplateRef, ViewContainerRef, signal, Directive, Input } from '@angular/core';\nimport { toObservable, toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { FormGroupDirective, NgForm } from '@angular/forms';\nimport { filterNil } from 'ngxtension/filter-nil';\nimport { BehaviorSubject, distinctUntilChanged, combineLatest, startWith, map, of, switchMap, shareReplay } from 'rxjs';\nconst dirty$ = control => {\n  const dirty$ = new BehaviorSubject(control.dirty);\n  const markAsPristine = control.markAsPristine.bind(control);\n  const markAsDirty = control.markAsDirty.bind(control);\n  control.markAsPristine = (...args) => {\n    markAsPristine(...args);\n    dirty$.next(false);\n  };\n  control.markAsDirty = (...args) => {\n    markAsDirty(...args);\n    dirty$.next(true);\n  };\n  return dirty$.pipe(distinctUntilChanged());\n};\nconst touched$ = control => {\n  const touched$ = new BehaviorSubject(control.touched);\n  const markAsTouched = control.markAsTouched.bind(control);\n  const markAsUntouched = control.markAsUntouched.bind(control);\n  control.markAsTouched = (...args) => {\n    markAsTouched(...args);\n    touched$.next(true);\n  };\n  control.markAsUntouched = (...args) => {\n    markAsUntouched(...args);\n    touched$.next(false);\n  };\n  return touched$.pipe(distinctUntilChanged());\n};\n/**\n * Emits whenever the value, status, touched/untouched state of the control changes or the parent submits.\n *\n * Evaluates to `true` when the control status is `INVALID` and it is `touched` or the parent is `submitted`.\n */\nconst NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER = (control, parent) => combineLatest([control.valueChanges.pipe(startWith(control.value)), control.statusChanges.pipe(startWith(control.status), distinctUntilChanged()), touched$(control), parent?.ngSubmit.pipe(map(() => true), startWith(parent.submitted), distinctUntilChanged()) ?? of(false)], (value, status, touched, submitted) => status === 'INVALID' && (touched || submitted));\nconst NGX_CONTROL_ERROR_STATE_MATCHER = new InjectionToken('NGX_CONTROL_ERROR_STATE_MATCHER', {\n  factory: () => NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER\n});\nconst NGX_CONTROL_ERROR_PARENT = new InjectionToken('NGX_CONTROL_ERROR_PARENT');\n/**\n * Configures {@link NgxControlError}.\n */\nconst provideNgxControlError = options => {\n  const provider = [];\n  if (options?.errorStateMatcher) provider.push({\n    provide: NGX_CONTROL_ERROR_STATE_MATCHER,\n    useFactory: options.errorStateMatcher\n  });\n  if (options?.parent) provider.push({\n    provide: NGX_CONTROL_ERROR_PARENT,\n    useFactory: options.parent\n  });\n  return provider;\n};\n/**\n * Structural directive for displaying form control errors consistently and reduce boilerplate.\n *\n * ## Usage\n *\n * ```html\n * <label>\n * \t<b>Name</b>\n * \t<input type=\"text\" [formControl]=\"name\" />\n * \t<strong *ngxControlError=\"name; track: 'required'\">Name is required.</strong>\n * </label>\n * ```\n *\n * The template will be rendered, when the control is in an [_error state_](#configuration) and its errors include the tracked error(s).\n *\n * without `NgxControlError`:\n *\n * ```html\n * <label>\n * \t<b>Name</b>\n * \t<input type=\"text\" [formControl]=\"name\" />\n * \t@if (name.hasError('required') && (name.touched || form.submitted)) {\n * \t<strong>Name is required.</strong>\n * \t}\n * </label>\n * ```\n *\n * ## Configuration\n *\n * A `StateMatcher` defines when the provided control is in an _error state_.\n * A `StateMatcher` is a function which returns an observable. Every time the `StateMatcher` emits a value, the directive checks whether it should render or hide its template:\n * The directive renders its template when the `StateMatcher` emits `true` and the errors of the control include at least 1 tracked error, else its template will be hidden.\n *\n * ```ts\n * export type StateMatcher = (\n * control: AbstractControl,\n * parent?: FormGroupDirective | NgForm,\n * ) => Observable<boolean>;\n * ```\n *\n * Per default the control is considered in an _error state_ when 1. its status is `INVALID` and 2. it is `touched` or its form has been `submitted`.\n *\n * You can override this behavior:\n *\n * ```ts\n * //\n * // A control is in an error state when its status is invalid.\n * // Emits whenever statusChanges emits.\n * // You may want to add more sources, such as valueChanges.\n * //\n * export const customErrorStateMatcher: StateMatcher = (control) =>\n * control.statusChanges.pipe(\n * startWith(control.status),\n * map((status) => status === 'INVALID'),\n * );\n * ```\n *\n * ### Via DI\n *\n * ```ts\n * provideNgxControlError({ errorStateMatcher: customErrorStateMatcher });\n * ```\n *\n * ### Via Input\n *\n * ```html\n * <label>\n * \t<b>Name</b>\n * \t<input type=\"text\" [formControl]=\"name\" />\n * \t<strong *ngxControlError=\"name; track: 'required'; errorStateMatcher: customErrorStateMatcher\">Name is required.</strong>\n * </label>\n * ```\n *\n * ## Integration\n *\n * ### [NGX Translate](https://github.com/ngx-translate/core)\n *\n * You can iterate over all possible errors and pass the `errors` to the translate pipe:\n *\n * ```html\n * <label>\n * \t<b>Mail</b>\n * \t<input type=\"email\" [formControl]=\"mail\" />\n * \t@for (error of ['required', 'email', 'myCustomError']; track error) {\n * \t<strong *ngxControlError=\"mail; track: error\">{{ \"PATH.TO.MAIL_CONTROL.ERRORS.\" + error | translate: mail.errors }}</strong>\n * \t}\n * </label>\n * ```\n *\n * ### [Angular Material](https://github.com/angular/components)\n *\n * ```html\n * <mat-form-field>\n * \t<mat-label>Name</mat-label>\n * \t<input matInput [formControl]=\"name\" />\n * \t<mat-error *ngxControlError=\"name; track: 'required'\">Name is required.</mat-error>\n * </mat-form-field>\n * ```\n */\nclass NgxControlError {\n  constructor() {\n    /** @ignore */\n    this.templateRef = inject(TemplateRef);\n    /** @ignore */\n    this.viewContainerRef = inject(ViewContainerRef);\n    /**\n     * The errors this directive tracks, when a {@link control$ control} is provided.\n     */\n    this.track$ = signal(undefined);\n    /**\n     * The parent of this {@link control$ control}.\n     *\n     * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.\n     */\n    this.parent$ = signal(inject(NGX_CONTROL_ERROR_PARENT, {\n      optional: true\n    }) ?? inject(FormGroupDirective, {\n      optional: true\n    }) ?? inject(NgForm, {\n      optional: true\n    }) ?? undefined);\n    /**\n     * The control which `errors` are tracked.\n     *\n     * @see {@link AbstractControl.errors}\n     */\n    this.control$ = signal(undefined);\n    /**\n     *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.\n     *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.\n     *\n     *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.\n     */\n    this.errorStateMatcher$ = signal(inject(NGX_CONTROL_ERROR_STATE_MATCHER));\n    /**\n     * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.\n     */\n    this._hasError$ = combineLatest([toObservable(this.track$), toObservable(this.errorStateMatcher$), toObservable(this.control$).pipe(filterNil()), toObservable(this.parent$)]).pipe(switchMap(([track, errorStateMatcher, control, parent]) => errorStateMatcher(control, parent).pipe(map(errorState => errorState && track != null && control != null && (typeof track === 'string' ? control.hasError(track) : track.some(x => control.hasError(x)))))), shareReplay(1));\n    /**\n     * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.\n     */\n    this.hasError$ = toSignal(this._hasError$, {\n      initialValue: false\n    });\n    // Whenever one of the tracked errors are included in the controls errors and the control is in an error state, render this template.\n    combineLatest([toObservable(this.track$), toObservable(this.control$), this._hasError$], (track, control, hasError) => {\n      this.viewContainerRef.clear();\n      if (hasError && control != null && track != null) this.viewContainerRef.createEmbeddedView(this.templateRef, {\n        $implicit: control.errors ?? {},\n        track,\n        control\n      });\n    }).pipe(takeUntilDestroyed()).subscribe();\n  }\n  /**\n   * The errors this directive tracks, when a {@link control$ control} is provided.\n   */\n  set track(track) {\n    this.track$.set(track);\n  }\n  get track() {\n    return this.track$();\n  }\n  /**\n   * The control which `errors` are tracked.\n   *\n   * @see {@link AbstractControl.errors}\n   */\n  set control(control) {\n    this.control$.set(control);\n  }\n  get control() {\n    return this.control$();\n  }\n  /**\n   *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.\n   *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.\n   *\n   *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.\n   */\n  set errorStateMatcher(errorStateMatcher) {\n    this.errorStateMatcher$.set(errorStateMatcher);\n  }\n  get errorStateMatcher() {\n    return this.errorStateMatcher$();\n  }\n  /**\n   * The parent of this {@link control$ control}.\n   *\n   * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.\n   */\n  set parent(parent) {\n    this.parent$.set(parent);\n  }\n  get parent() {\n    return this.parent$();\n  }\n  /**\n   * The context of this template.\n   */\n  get context() {\n    return this.viewContainerRef.get(0)?.context;\n  }\n  /** @ignore */\n  static {\n    this.ngTemplateContextGuard = (directive, context) => true;\n  }\n  static {\n    this.ɵfac = function NgxControlError_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxControlError)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgxControlError,\n      selectors: [[\"\", \"ngxControlError\", \"\"]],\n      inputs: {\n        track: [0, \"ngxControlErrorTrack\", \"track\"],\n        control: [0, \"ngxControlError\", \"control\"],\n        errorStateMatcher: [0, \"ngxControlErrorErrorStateMatcher\", \"errorStateMatcher\"],\n        parent: [0, \"ngxControlErrorParent\", \"parent\"]\n      },\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxControlError, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxControlError]',\n      standalone: true\n    }]\n  }], () => [], {\n    track: [{\n      type: Input,\n      args: [{\n        alias: 'ngxControlErrorTrack',\n        required: true\n      }]\n    }],\n    control: [{\n      type: Input,\n      args: [{\n        alias: 'ngxControlError',\n        required: true\n      }]\n    }],\n    errorStateMatcher: [{\n      type: Input,\n      args: [{\n        alias: 'ngxControlErrorErrorStateMatcher'\n      }]\n    }],\n    parent: [{\n      type: Input,\n      args: [{\n        alias: 'ngxControlErrorParent'\n      }]\n    }]\n  });\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_CONTROL_ERROR_PARENT, NGX_CONTROL_ERROR_STATE_MATCHER, NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER, NgxControlError, dirty$, provideNgxControlError, touched$ };\n"],
  "mappings": "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",
  "names": ["import_rxjs", "dirty$", "touched$"]
}
